#include "core/lightglue.h"
#include "core/superpoint.h"
#include <opencv2/opencv.hpp>
#include <iostream>
#include <stdexcept>
#include <vector>
#include <algorithm>
#include <cmath>
#include <random>

static void drawSuperPointKpts(cv::Mat& imgBgr, const std::vector<float>& kptsXY, int N,
                               const cv::Scalar& color = cv::Scalar(0, 255, 0),
                               int radius = 2, int thickness = 1) {
    for (int i = 0; i < N; ++i) {
        float x = kptsXY[size_t(i)*2 + 0];
        float y = kptsXY[size_t(i)*2 + 1];
        cv::circle(imgBgr, cv::Point2f(x, y), radius, color, thickness, cv::LINE_AA);
    }
}

static cv::Mat concatHorizontalSameSize(const cv::Mat& left, const cv::Mat& right) {
    // assumes both are same size/type
    cv::Mat out(left.rows, left.cols + right.cols, left.type());
    left.copyTo(out(cv::Rect(0, 0, left.cols, left.rows)));
    right.copyTo(out(cv::Rect(left.cols, 0, right.cols, right.rows)));
    return out;
}

static void drawLightGlueMatches(cv::Mat& vis,                      // BGR concat image (img0 | img1)
                                 int img0Width,                     // width of left image
                                 const std::vector<float>& kpts0,   // [N0,2]
                                 const std::vector<float>& kpts1,   // [N1,2]
                                 const std::vector<int64_t>& matches0, // [N0]
                                 const std::vector<float>& mscores0,   // [N0]
                                 int N0, int N1,
                                 int maxToDraw = 500,
                                 float minScore = 0.0f) {
    // Optionally collect matched indices with scores for sorting by confidence
    struct M { int i; int j; float s; };
    std::vector<M> mlist;
    mlist.reserve(N0);
    for (int i = 0; i < N0; ++i) {
        int j = static_cast<int>(matches0[i]);
        if (j >= 0 && j < N1) {
            float s = mscores0[i];
            if (s >= minScore) {
                mlist.push_back({i, j, s});
            }
        }
    }

    // Sort by score descending (optional), then draw top K
    std::sort(mlist.begin(), mlist.end(), [](const M& a, const M& b){ return a.s > b.s; });
    if ((int)mlist.size() > maxToDraw) mlist.resize(maxToDraw);

    // Color map: stronger score => greener/brighter
    for (const auto& m : mlist) {
        float x0 = kpts0[size_t(m.i)*2 + 0];
        float y0 = kpts0[size_t(m.i)*2 + 1];
        float x1 = kpts1[size_t(m.j)*2 + 0] + img0Width;  // shift for concatenated image
        float y1 = kpts1[size_t(m.j)*2 + 1];

        // Map score [0..1] to color (B,G,R), e.g., low=red, high=green
        float s = std::max(0.f, std::min(1.f, m.s));
        cv::Scalar color = cv::Scalar(0, 255*s, 255*(1.0f - s));  // from red to green

        // Draw endpoints
        cv::circle(vis, cv::Point2f(x0, y0), 2, color, -1, cv::LINE_AA);
        cv::circle(vis, cv::Point2f(x1, y1), 2, color, -1, cv::LINE_AA);

        // Draw line
        cv::line(vis, cv::Point2f(x0, y0), cv::Point2f(x1, y1), color, 1, cv::LINE_AA);
    }
}


static void toFloatKpts(const std::vector<int64_t>& kptsIntXY, int N, std::vector<float>& kptsFloatXY) {
    kptsFloatXY.resize(size_t(N) * 2);
    for (int i = 0; i < N; ++i) {
        kptsFloatXY[size_t(i)*2 + 0] = static_cast<float>(kptsIntXY[size_t(i)*2 + 0]);
        kptsFloatXY[size_t(i)*2 + 1] = static_cast<float>(kptsIntXY[size_t(i)*2 + 1]);
    }
}

static void sliceDescriptors(const std::vector<float>& descAll, int N, std::vector<float>& descOut) {
    // descAll is length maxKpts*256; take only first N rows
    descOut.assign(descAll.begin(), descAll.begin() + size_t(N) * 256);
}

static inline void l2NormalizeRow(float* row, int D = 256) {
    double s = 0.0;
    for (int d = 0; d < D; ++d) s += double(row[d]) * double(row[d]);
    float inv = 1.0f / std::max(float(std::sqrt(s)), 1e-6f);
    for (int d = 0; d < D; ++d) row[d] *= inv;
}

static void l2NormalizeDescriptors(std::vector<float>& desc, int N, int D = 256) {
    for (int i = 0; i < N; ++i) {
        l2NormalizeRow(&desc[size_t(i) * D], D);
    }
}

int main() {
    try {
        // Initialize SuperPoint (builds/loads engine once)
        SuperPointTRT sp;
        sp.setWorkspaceSizeBytes(2ULL << 30);
        sp.setMaxKeypoints(2048);
        sp.setScoreThreshold(0.0f); // adjust if desired

        // Use the same resolution you used to build the engine (min=opt=max)
        const int spH = 376;
        const int spW = 1241;
        if (!sp.init("superpoint_2048.onnx", "superpoint_2048.engine", spH, spW)) {
            throw std::runtime_error("SuperPoint init failed");
        }

        // Read two images (grayscale), preprocess to float32 [0,1]
        cv::Mat img0 = cv::imread("temp3.png", cv::IMREAD_GRAYSCALE);
        cv::Mat img1 = cv::imread("temp4.png", cv::IMREAD_GRAYSCALE);
        if (img0.empty() || img1.empty()) {
            throw std::runtime_error("Failed to load image0.png or image1.png");
        }

        // Convert to float32 [0,1]; if engine is fixed-size, ensure images already match (you set min=opt=max)
        cv::Mat img0f, img1f;
        img0.convertTo(img0f, CV_32F, 1.0/255.0);
        img1.convertTo(img1f, CV_32F, 1.0/255.0);

        // Run SuperPoint on both images
        SuperPointTRT::Result spRes0, spRes1;
        if (!sp.runInference(reinterpret_cast<const float*>(img0f.data), img0f.rows, img0f.cols, spRes0)) {
            throw std::runtime_error("SuperPoint inference failed on image0");
        }
        if (!sp.runInference(reinterpret_cast<const float*>(img1f.data), img1f.rows, img1f.cols, spRes1)) {
            throw std::runtime_error("SuperPoint inference failed on image1");
        }

        std::cout << "Image0: valid keypoints = " << spRes0.numValid << std::endl;
        std::cout << "Image1: valid keypoints = " << spRes1.numValid << std::endl;

        // Prepare LightGlue inputs from SuperPoint results
        // You currently force N0=N1=2048; consider using numValid or a top-K if needed.
        const int N0 = 2048;
        const int N1 = 2048;
        if (N0 <= 0 || N1 <= 0) {
            std::cerr << "No valid keypoints in one or both images; skipping matching." << std::endl;
            return 0;
        }

        std::vector<float> kpts0_f, kpts1_f;
        std::vector<float> desc0_f, desc1_f;
        toFloatKpts(spRes0.keypoints, N0, kpts0_f);
        toFloatKpts(spRes1.keypoints, N1, kpts1_f);
        sliceDescriptors(spRes0.descriptors, N0, desc0_f);
        sliceDescriptors(spRes1.descriptors, N1, desc1_f);

        // L2-normalize SuperPoint descriptors BEFORE LightGlue
        l2NormalizeDescriptors(desc0_f, N0, 256);
        l2NormalizeDescriptors(desc1_f, N1, 256);

        // Initialize LightGlue
        LightGlueTRT lg;
        if (!lg.init("superpoint_lightglue.onnx", "superpoint_lightglue.engine")) {
            throw std::runtime_error("LightGlueTRT init failed");
        }

        // Run LightGlue
        LightGlueTRT::Result lgRes;
        if (!lg.runInference(kpts0_f, desc0_f, kpts1_f, desc1_f, N0, N1, lgRes)) {
            throw std::runtime_error("LightGlueTRT inference failed");
        }

        // Print a summary of matches
        int nMatches = 0;
        for (int i = 0; i < N0; ++i) {
            if (lgRes.matches0[i] >= 0) ++nMatches;
        }
        std::cout << "LightGlue matches: " << nMatches << " (of " << N0 << " keypoints in image0)" << std::endl;

        // Print first few matched pairs with scores
        int printed = 0;
        for (int i = 0; i < N0 && printed < 10; ++i) {
            int j = static_cast<int>(lgRes.matches0[i]);
            if (j >= 0 && j < N1) {
                float score = lgRes.mscores0[i];
                float x0 = kpts0_f[size_t(i)*2 + 0];
                float y0 = kpts0_f[size_t(i)*2 + 1];
                float x1 = kpts1_f[size_t(j)*2 + 0];
                float y1 = kpts1_f[size_t(j)*2 + 1];
                std::cout << "i=" << i << " (" << x0 << "," << y0 << ") "
                          << "<-> j=" << j << " (" << x1 << "," << y1 << ") "
                          << " score=" << score << std::endl;
                ++printed;
            }
        }

        // Prepare BGR visuals (convert the float grayscale or original grayscale to BGR)
        cv::Mat img0_vis, img1_vis;
        cv::cvtColor(img0, img0_vis, cv::COLOR_GRAY2BGR);
        cv::cvtColor(img1, img1_vis, cv::COLOR_GRAY2BGR);

        // Draw SuperPoint keypoints used for LightGlue (N0/N1)
        drawSuperPointKpts(img0_vis, kpts0_f, N0, cv::Scalar(0, 200, 0), 2, 1);
        drawSuperPointKpts(img1_vis, kpts1_f, N1, cv::Scalar(0, 200, 0), 2, 1);

        // Concatenate and draw LightGlue matches
        cv::Mat concat = concatHorizontalSameSize(img0_vis, img1_vis);

        // You can filter by a score and draw a subset for clarity
        drawLightGlueMatches(concat, img0_vis.cols,
                            kpts0_f, kpts1_f,
                            lgRes.matches0, lgRes.mscores0,
                            N0, N1,
                            /*maxToDraw=*/1000, /*minScore=*/0.0f);

        // Show or save
        cv::imshow("SuperPoint+LightGlue Matches", concat);
        cv::imwrite("matches_vis.png", concat);

        // Optionally visualize standalone SuperPoint keypoints per image
        cv::imshow("SP keypoints - img0", img0_vis);
        cv::imshow("SP keypoints - img1", img1_vis);
        cv::imwrite("sp_kpts_img0.png", img0_vis);
        cv::imwrite("sp_kpts_img1.png", img1_vis);

        cv::waitKey(0);


        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Fatal: " << e.what() << std::endl;
        return -1;
    }
}
